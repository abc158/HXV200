###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        23/Sep/2017  15:46:26
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\海尔\新版+8k解码+预约\src\local_process\act.c
#    Command line =  
#        F:\海尔\新版+8k解码+预约\src\local_process\act.c -lcN
#        F:\海尔\新版+8k解码+预约\project\Debug\List\ --diag_error PE223 -o
#        F:\海尔\新版+8k解码+预约\project\Debug\Obj\ --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" --preinclude
#        F:\海尔\新版+8k解码+预约\project\..\lib\syscall_api.h -I
#        F:\海尔\新版+8k解码+预约\project\..\includes\ -I
#        F:\海尔\新版+8k解码+预约\project\..\src\includes\ -I
#        F:\海尔\新版+8k解码+预约\project\..\lib\ -I
#        F:\海尔\新版+8k解码+预约\project\..\src\ -I
#        F:\海尔\新版+8k解码+预约\project\..\src\local_process\ -I
#        F:\海尔\新版+8k解码+预约\project\..\src\cfg\ -I
#        F:\海尔\新版+8k解码+预约\project\..\src\dock\ -I
#        F:\海尔\新版+8k解码+预约\project\..\src\guardrail\ -Ohz
#    List file    =  F:\海尔\新版+8k解码+预约\project\Debug\List\act.lst
#    Object file  =  F:\海尔\新版+8k解码+预约\project\Debug\Obj\act.o
#
###############################################################################

F:\海尔\新版+8k解码+预约\src\local_process\act.c
      1          //------------------------------------------------------------------------------
      2          //  Copyright (C) 2014-2017, Amicro, Inc.
      3          //  All rights reserved.
      4          //------------------------------------------------------------------------------
      5          #include <ui-config.h>
      6          #include "ui-commands.h"
      7          #include "am_date_base.h"
      8          #include "am_config_macro.h"
      9          #include "time.h"
     10          #include "lib.h"
     11          #include "local_key_check.h"
     12          #include "syscall_api.h"
     13          #include "remote.h"
     14          #include "act.h"
     15          #include "display.h"
     16          #include "am_key.h"
     17          #include "sensor/sensor.h"
     18          #include "ui-manager/exception.h"
     19          #include "motor/robot_suction.h"
     20          #include "ui-song-player.h"
     21          #include "charge/charge.h"
     22          #include "motor/motor.h"
     23          
     24          #include "state_view/state_view.h"
     25          
     26          #ifdef USE_WIFI_DEMO_1
     27          #include "wifi/wifi_demo1/simwifi.h"
     28          #include "wifi/wifi_demo1/simsweep.h"
     29          #elif defined(USE_WIFI_DEMO_2)
     30          #include "wifi/wifi_demo2/simwifi_demo2.h"
     31          #include "wifi/wifi_demo2/SimSweep_demo2.h"
     32          #endif
     33          #include "motor/robot_brush.h"
     34          #define GO_SLEEP_TIME 500
     35          #define WAITING_SLEEP_TIME 6000
     36          #define FULLGO_START_TIME 200
     37          #define WIFI_SLEEP_TIME    30000
     38          typedef enum
     39          {
     40            SPOT_MODE_NONE,
     41            SPOT_MODE_SPIRAL,/*螺旋清扫*/
     42            SPOT_MODE_GRID   /*局部弓字形*/
     43          }SPOT_MODE_E;
     44          
     45          static tm tmp_day;
     46          static schedule_time_info tmp_schedule_info;
     47          static UI_STATE_E ui_state;                   /*UI状态*/
     48          static sys_state_info sys_state_info_p;       /*系统状态*/
     49          static key_state_t *key_state_p;              /*物理按键状态指针*/
     50          static ir_state_t *key_ir_p;                  /*物理按键状态指针*/
     51          
     52          static cmd_state_t *wifi_uart_cmd_state_p;   /*物理按键状态指针*/
     53          static U8 enter_sleep_state = 0;              /*睡眠模式,有些方案可能要求不同睡眠模式*/
     54          //static U8 fullgo_flag = 0;       
     55          static U8 start_docking_flag = 0;             /*是否需要回座的标志*/
     56          u8 ui_test_index = 0;                         /*测试项序号*/
     57          U8 clean_index = 0;
     58          TEST_CMD_E ui_test_cmd = CMD_TEST_WAIT;       /*测试项命令,根据ui_test_index从test_item_table[]中获得*/
     59          u8 allow_self_test = 1;                       /*是否可以进入自检模式*/
     60          static u16 goto_sleep_cnt = 0;                /*进入睡眠的时间计数*/
     61          static u16 waiting_state_cnt = 0;
     62          static u8 enhance_mode = 0;                   /*加强模式*/
     63          static SPOT_MODE_E spot_mode = SPOT_MODE_NONE;/*局部清扫模式*/
     64          static u8 board_key;                          /*物理按键*/
     65          static u8 ir_key;                             /*遥控按键*/
     66          static u16 fullgo_cnt;                        /*fullgo计时*/
     67          u8 direction_key_up_flag;//方向键松开标志位
     68          u8 direction_key_pause;//1:表示在方向键中发了暂停命令
     69          u8 clean_pause_flag = 0;
     70          u8 special_sleep_flag = 0;
     71          static U8 adjust_side_brush_flag = 0;
     72          static U8 wifi_flag = 0;
     73          extern TEST_CMD_E test_item_table[];
     74          void robot_suction_ctrl(BOOLEAN en);
     75           static uint16_t vac_current_count;
     76          static U8 wifi_press_long_flag = 0;
     77          U8 wifi_led=0;
     78          void handle_act(U32 key_val);
     79          extern cmd_state_t *get_ui_uart_cmd_state(void);
     80          extern void sys_shutdown(void);
     81          extern cmd_state_t *get_wifi_uart_cmd_state(void);
     82          EXPORT motor_encode_t *motor_encode_get(void);
     83          extern u8 battery_switch_check(void);
     84          void direction_key_recover_handle(void);
     85          
     86          
     87          UI_STATE_E get_ui_state(void)
     88          {
     89            return ui_state;
     90          }
     91          
     92          void set_ui_state(UI_STATE_E s)
     93          {
     94            ui_state = s;
     95          }
     96          
     97          U8 get_enter_sleep_state(void)
     98          {
     99            return enter_sleep_state;
    100          }
    101          
    102          void set_enter_sleep_state(U8 state)
    103          {
    104            enter_sleep_state = state;
    105          }
    106          
    107          void set_start_docking_state(u8 state)
    108          {
    109            start_docking_flag = state;
    110          }
    111          
    112          u8 get_start_docking_state(void)
    113          {
    114            return start_docking_flag;
    115          }
    116          /****************************************************************
    117          *Function   :  _act_init
    118          *Description:  命令执行模块的初始化  
    119          *Input      :  无
    120          *Output     :  无
    121          *Return     :  无
    122          *Others     :  
    123          ******************************************************************/
    124          void _act_init(void)
    125          {
    126            key_state_p = get_key_state();
    127            key_ir_p    = get_ir_state();
    128            
    129            wifi_uart_cmd_state_p = get_wifi_uart_cmd_state();
    130            clear_map_index();
    131          
    132          }
    133          
    134          /****************************************************************
    135          *Function   :  _act_exit
    136          *Description:  行为的退出  
    137          *Input      :  无
    138          *Output     :  无
    139          *Return     :  无
    140          *Others     :  
    141          ******************************************************************/
    142          void _act_exit(void)
    143          {
    144            ;
    145          }
    146          
    147          /****************************************************************
    148          *Function   :  sleep_handle
    149          *Description:  睡眠状态的处理  
    150          *Input      :  按键消息
    151          *Output     :  1：函数执行时处理了按键消息了；0：函数执行时没有处理按键消息
    152          *Return     :  无
    153          *Others     :  
    154          ******************************************************************/
    155          u8 sleep_handle(U32 key)
    156          {
    157          	if (get_ui_state() == UI_ENTER_SLEEPING)
    158          	{
    159          		if (((key == (KEY_CLEAN | KEY_SHORT_UP))&&(board_key))||
    160                   (key == (KEY_POWER | KEY_SHORT_UP))||
    161                   (sys_state_info_p.robot_state == ROBOT_STATE_CHARGING)||
    162                   (sys_state_info_p.robot_state == ROBOT_STATE_CLEANING_ROOM))
    163          		{
    164                      robot_universl_wheel_init();
    165          		    set_ui_state(UI_IDLE);
    166                   
    167          		  
    168          		}
    169          		else
    170          		{
    171          		  goto_sleep_cnt++;
    172          		  if (goto_sleep_cnt >= GO_SLEEP_TIME)
    173          		  {
    174          		  	 goto_sleep_cnt = 0;
    175                   robot_universl_wheel_exit();
    176          		     act_command_q(CMD_POWER, CMD_RUN, NULL, 0);
    177          		  }
    178          		}
    179              return 1;
    180          	}
    181          	return 0;
    182          }
    183          
    184          /****************************************************************
    185          *Function   :  ext_act_handle
    186          *Description:  方案规格相关的行为处理  
    187          *Input      :  按键消息
    188          *Output     :  1：函数执行时处理了按键消息了；0：函数执行时没有处理按键消息
    189          *Return     :  无
    190          *Others     :  
    191          ******************************************************************/
    192          u8 ext_act_handle(U32 key)
    193          {
    194          	UI_STATE_E s;
    195              U16 tmp_sleep_time = 0;
    196          	s = get_ui_state();
    197          	//是否打开墙检和地检
    198          	if ( (sys_state_info_p.robot_state != ROBOT_STATE_WAITING &&
    199            	    sys_state_info_p.robot_state != ROBOT_STATE_CHARGING)
    200            	    || (get_ui_state() == UI_TEST) )
    201            {
    202              robot_sensor_gather_start(1);
    203            }
    204            else
    205            {
    206              robot_sensor_gather_start(0);
    207            }  
    208            //停止状态一段时间后进入睡眠
    209            if (sys_state_info_p.robot_state == ROBOT_STATE_WAITING)
    210            {    
    211              if ((s != UI_ERROR) && (s != UI_TEST) && (s != UI_ENTER_SLEEPING))
    212              {
    213              	waiting_state_cnt++;
    214                if(wifi_flag > 0)
    215                   tmp_sleep_time = WIFI_SLEEP_TIME;
    216                else
    217                   tmp_sleep_time = WAITING_SLEEP_TIME;
    218                
    219                if (waiting_state_cnt >= tmp_sleep_time)
    220                {
    221                   waiting_state_cnt = 0;
    222                   if(wifi_flag > 0)
    223                      wifi_flag = 0;
    224                   gpio_set_value(AM_I0_WIFI_LED, 0);
    225                   set_ui_state(UI_ENTER_SLEEPING);
    226                }
    227              }
    228              else
    229              {
    230                waiting_state_cnt = 0;
    231              }        
    232            }
    233            else
    234            {
    235               waiting_state_cnt = 0;
    236            }
    237            //dock处理
    238            if (get_start_docking_state() == 1 && sys_state_info_p.dock_state == 0)
    239          	{
    240          		act_command_q(CMD_DOCK, CMD_RUN, NULL, 0);
    241          		songplayer_play_id(SONG_ID_DOCKING_START, 0);
    242          	  set_start_docking_state(0);
    243          	}
    244          	//fullgo处理
    245          	if (get_ui_state() == UI_FULLGO)
    246          	{
    247          	  if ( (sys_state_info_p.robot_state == ROBOT_STATE_WAITING) ||
    248          	  	   ((sys_state_info_p.robot_state == ROBOT_STATE_CHARGING) && 
    249          	  	    (sys_state_info_p.charging_state == CHARGING_COMPLETE)) ) 
    250          	  {
    251          	    fullgo_cnt++;
    252          	    if (fullgo_cnt > FULLGO_START_TIME)
    253          	    {
    254          	      act_command_q(CMD_CLEAN, CMD_RUN, NULL, 0);
    255          	      fullgo_cnt = 0;
    256          	    }
    257          	  }
    258          	  else
    259          	  {
    260          	    fullgo_cnt = 0;
    261          	  }
    262          	}
    263          	//sleep处理
    264          	if (sleep_handle(key) == 1)
    265          	{
    266          	  return 1;
    267          	}
    268          	//故障处理
    269          	exception_handle();
    270          	
    271          	return 0;
    272          }
    273          
    274          /****************************************************************
    275          *Function   :  act_routine
    276          *Description:  行为处理函数  
    277          *Input      :  无
    278          *Output     :  无
    279          *Return     :  无
    280          *Others     :  
    281          ******************************************************************/
    282          void act_routine(void)
    283          {
    284            U8 i;
    285            U32 key_value = KEY_NULL;      
    286            
    287            //物理按键消息获取
    288            for(i=0; i<TOTAL_KEY_NUM; i++)
    289            {
    290              if(key_state_p[i].state != KEY_NULL)
    291              {
    292                //printf("key_value phy =%x\r\n",key_value);
    293                key_value = key_state_p[i].state | key_state_p[i].keyval;
    294                key_state_p[i].state = KEY_NULL;//clear the message
    295                board_key = 1;
    296              } 
    297            }
    298            //遥控按键消息或者
    299            for(i=0; i<TOTAL_IR_NUM; i++)
    300            {
    301              if(key_ir_p[i].state != KEY_NULL)
    302              {
    303                key_value = key_ir_p[i].state | key_ir_p[i].keyval;
    304                
    305                //printf("key_value ir =%x\r\n",key_value);
    306                
    307                key_ir_p[i].state = KEY_NULL;//clear the message 
    308                ir_key = 1;
    309              } 
    310            }
    311           
    312           
    313            #ifdef USE_UART_WIFI
    314            for(i=0; i<UART_CMD_MAX; i++)
    315            {
    316               if(wifi_uart_cmd_state_p[i].state != KEY_NULL)
    317               {
    318                 key_value = wifi_uart_cmd_state_p[i].state | wifi_uart_cmd_state_p[i].keyval;
    319                 wifi_uart_cmd_state_p[i].state = KEY_NULL;//clear the message
    320               } 
    321            }
    322            #endif
    323           //规格相关的一些处理
    324          	if (ext_act_handle(key_value) == 1)
    325          	{
    326          	  return;
    327          	}
    328          	//按键消息处理
    329            if (key_value != KEY_NULL)
    330            {
    331              handle_act(key_value);
    332              board_key = 0;
    333              ir_key = 0;
    334            }  
    335            direction_key_recover_handle();
    336          }
    337          
    338          /****************************************************************
    339          *Function   :  handle_act_waiting
    340          *Description:  系统状态为ROBOT_STATE_WAITING的按键响应函数  
    341          *Input      :  按键消息
    342          *Output     :  无
    343          *Return     :  无
    344          *Others     :  
    345          ******************************************************************/
    346          void handle_act_waiting(U32 key_val)
    347          {  
    348          // printf("handle_act_waiting\r\n"); 
    349            
    350            switch(key_val)
    351            { 
    352              case KEY_CLEAN | KEY_SHORT_UP:
    353                      clear_map_index();
    354          
    355                act_command_q(CMD_CLEAN, CMD_RUN, NULL, 0);
    356                songplayer_play_id(SONG_ID_NORMAL_CLEANING_START, 0);
    357                break;
    358                
    359              case KEY_DOCK | KEY_SHORT_UP:
    360                act_command_q(CMD_DOCK, CMD_RUN, NULL, 0);
    361                songplayer_play_id(SONG_ID_DOCKING_START, 0);
    362                break;
    363              
    364              case KEY_SPOT | KEY_SHORT_UP:
    365          	  state_save_and_recover_grid(0);
    366                act_command_q(CMD_SPOT, CMD_RUN, NULL, 0);
    367                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    368                spot_mode = SPOT_MODE_SPIRAL;
    369                break;
    370              
    371              case KEY_GRID | KEY_SHORT_UP:
    372          	  state_save_and_recover_grid(0);
    373                act_command_q(CMD_GRID1, CMD_RUN, NULL, 0);
    374                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    375                spot_mode = SPOT_MODE_GRID;
    376                break;
    377                    
    378              case KEY_WALLFLOW | KEY_SHORT_UP:
    379                act_command_q(CMD_WALL_FOLLOW, CMD_RUN, NULL, 0);
    380                songplayer_play_id(SONG_ID_WALLFOLLOW_CLEANING_START, 0);
    381                break;          
    382                
    383              case KEY_POWER | KEY_SHORT_UP:   
    384              	goto_sleep_cnt = GO_SLEEP_TIME;  
    385              	songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
    386              	sleep(10); 
    387                set_ui_state(UI_ENTER_SLEEPING);
    388                break;                                          
    389                  
    390              default:
    391              	//printf("default=%x \r\n", s->cmd);
    392                break;         
    393            }    
    394          }
    395          
    396          /****************************************************************
    397          *Function   :  handle_act_running
    398          *Description:  系统状态为ROBOT_STATE_CLEANING_ROOM的按键响应函数  
    399          *Input      :  按键消息
    400          *Output     :  无
    401          *Return     :  无
    402          *Others     :  
    403          ******************************************************************/
    404          void handle_act_running(U32 key_val)
    405          {  
    406           // printf("handle_act_running\r\n"); 
    407            switch(key_val)
    408            { 
    409              case KEY_CLEAN | KEY_SHORT_UP:
    410                act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);   
    411                clean_pause_flag =1;
    412                sleep(10);
    413          	  songplayer_play_id(SONG_ID_ENTER_PAUSED, 0);
    414                break;
    415                
    416              case KEY_DOCK | KEY_SHORT_UP:
    417                act_command_q(CMD_DOCK, CMD_RUN, NULL, 0);
    418                songplayer_play_id(SONG_ID_DOCKING_START, 0);
    419                break;
    420              
    421              case KEY_SPOT | KEY_SHORT_UP:
    422          //      act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);
    423          //      sleep(10);
    424          	  state_save_and_recover_grid(0);
    425                act_command_q(CMD_SPOT, CMD_RUN, NULL, 0);
    426                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    427                spot_mode = SPOT_MODE_SPIRAL;
    428                break;
    429              
    430              case KEY_GRID | KEY_SHORT_UP:
    431              	//act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    432              	//sleep(10);
    433          	  state_save_and_recover_grid(0);
    434                act_command_q(CMD_GRID1, CMD_RUN, NULL, 0);
    435                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    436                spot_mode = SPOT_MODE_GRID;
    437                break;
    438                    
    439              case KEY_WALLFLOW | KEY_SHORT_UP:
    440              	//act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    441              	//sleep(10);
    442                act_command_q(CMD_WALL_FOLLOW, CMD_RUN, NULL, 0);
    443                songplayer_play_id(SONG_ID_WALLFOLLOW_CLEANING_START, 0);
    444                break;          
    445                
    446              case KEY_POWER | KEY_SHORT_UP:
    447                act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    448                songplayer_play_id(SONG_ID_NORMAL_CLEANING_STOP, 0);
    449                break;  
    450                
    451               case KEY_ADJUST | KEY_SHORT_UP:
    452                  // enhance_mode = 1;
    453                  robot_suction_vols_set(VACUUM_NORMAL_VOLTAGE);
    454          
    455                break;     
    456               case KEY_ADJUST1 | KEY_SHORT_UP:
    457                 {
    458                 // enhance_mode = 0;
    459                  robot_suction_vols_set(VACUUM_ENHANCE_VOLTAGE);       
    460                 }
    461                 break;
    462              default:
    463              	//printf("default=%x \r\n", s->cmd);
    464                break;         
    465            } 
    466                
    467          }
    468          
    469          /****************************************************************
    470          *Function   :  handle_act_pausing
    471          *Description:  系统状态为ROBOT_STATE_PAUSE的按键响应函数  
    472          *Input      :  按键消息
    473          *Output     :  无
    474          *Return     :  无
    475          *Others     :  
    476          ******************************************************************/
    477          void handle_act_pausing(U32 key_val)
    478          {  
    479           // printf("handle_act_pausing\r\n"); 
    480            switch(key_val)
    481            { 
    482              case KEY_CLEAN | KEY_SHORT_UP:
    483                if(clean_pause_flag == 1)
    484                {
    485                      act_command_q(CMD_PAUSE, CMD_RUN, NULL, 0);
    486                      clean_pause_flag =0;
    487                }           
    488                else
    489                      act_command_q(CMD_CLEAN, CMD_RUN, NULL, 0);
    490                songplayer_play_id(SONG_ID_NORMAL_CLEANING_START, 0);
    491                break;
    492                
    493              case KEY_DOCK | KEY_SHORT_UP:
    494                act_command_q(CMD_DOCK, CMD_RUN, NULL, 0);
    495                songplayer_play_id(SONG_ID_DOCKING_START, 0);
    496                break;
    497              
    498              case KEY_SPOT | KEY_SHORT_UP:
    499          	  state_save_and_recover_grid(0);
    500                act_command_q(CMD_SPOT, CMD_RUN, NULL, 0);
    501                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    502                spot_mode = SPOT_MODE_SPIRAL;
    503                break;
    504              
    505              case KEY_GRID | KEY_SHORT_UP:
    506          	  state_save_and_recover_grid(0);
    507                act_command_q(CMD_GRID1, CMD_RUN, NULL, 0);
    508                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    509                spot_mode = SPOT_MODE_GRID;
    510                break;
    511                    
    512              case KEY_WALLFLOW | KEY_SHORT_UP:
    513                act_command_q(CMD_WALL_FOLLOW, CMD_RUN, NULL, 0);
    514                songplayer_play_id(SONG_ID_WALLFOLLOW_CLEANING_START, 0);
    515                break;          
    516              
    517              case KEY_POWER | KEY_SHORT_UP:
    518                act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    519                sleep(10);
    520                goto_sleep_cnt = GO_SLEEP_TIME;  
    521                songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
    522                sleep(10); 
    523                set_ui_state(UI_ENTER_SLEEPING);
    524                special_sleep_flag = 1;
    525                break;                                          
    526                  
    527              default:
    528              	//printf("default=%x \r\n", s->cmd);
    529                break;         
    530            }     
    531          }
    532          
    533          /****************************************************************
    534          *Function   :  handle_act_spotting
    535          *Description:  系统状态为ROBOT_STATE_SPOTTING的按键响应函数  
    536          *Input      :  按键消息
    537          *Output     :  无
    538          *Return     :  无
    539          *Others     :  
    540          ******************************************************************/
    541          void handle_act_spotting(U32 key_val)
    542          {  
    543           // printf("handle_act_spotting\r\n"); 
    544            switch(key_val)
    545            { 
    546              case KEY_CLEAN | KEY_SHORT_UP:
    547                     // clear_map_index();
    548          
    549              	//act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    550              	//sleep(10);
    551                act_command_q(CMD_CLEAN, CMD_RUN, NULL, 0);
    552                songplayer_play_id(SONG_ID_NORMAL_CLEANING_START, 0);
    553                spot_mode = SPOT_MODE_NONE;
    554                break;
    555                
    556              case KEY_DOCK | KEY_SHORT_UP:
    557                act_command_q(CMD_DOCK, CMD_RUN, NULL, 0);
    558                songplayer_play_id(SONG_ID_DOCKING_START, 0);
    559                spot_mode = SPOT_MODE_NONE;      
    560                break;
    561              
    562              case KEY_SPOT | KEY_SHORT_UP:
    563              	//
    564                if (spot_mode == SPOT_MODE_GRID)
    565                {
    566                  act_command_q(CMD_SPOT, CMD_RUN, NULL, 0);
    567                  songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    568                  spot_mode = SPOT_MODE_SPIRAL;
    569                }
    570                else
    571                {
    572          		act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);
    573                	songplayer_play_id(SONG_ID_ENTER_PAUSED, 0);
    574                	spot_mode = SPOT_MODE_NONE;
    575                }
    576                break;
    577              
    578              case KEY_GRID | KEY_SHORT_UP:
    579              	//act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);    	
    580                if (spot_mode == SPOT_MODE_SPIRAL)
    581                {
    582                  act_command_q(CMD_GRID1, CMD_RUN, NULL, 0);
    583                  songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    584                  spot_mode = SPOT_MODE_GRID;
    585                }
    586                else
    587                {
    588          		act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);
    589                	songplayer_play_id(SONG_ID_ENTER_PAUSED, 0);
    590                	spot_mode = SPOT_MODE_NONE;
    591                }
    592                break;
    593                    
    594              case KEY_WALLFLOW | KEY_SHORT_UP:
    595              	//act_command_q(CMD_SPOT, CMD_STOP, NULL, 0);
    596              	//sleep(10);
    597                act_command_q(CMD_WALL_FOLLOW, CMD_RUN, NULL, 0);
    598                songplayer_play_id(SONG_ID_WALLFOLLOW_CLEANING_START, 0);
    599                spot_mode = SPOT_MODE_NONE;
    600                break;          
    601              
    602              case KEY_POWER | KEY_SHORT_UP:
    603                act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    604                songplayer_play_id(SONG_ID_NORMAL_CLEANING_STOP, 0);
    605                spot_mode = SPOT_MODE_NONE;
    606                break;      
    607                
    608               case KEY_ADJUST | KEY_SHORT_UP:
    609                 printf("KEY_ADJUST");
    610                  // enhance_mode = 1;
    611                  robot_suction_vols_set(VACUUM_NORMAL_VOLTAGE);
    612          
    613                break;     
    614               case KEY_ADJUST1 | KEY_SHORT_UP:
    615                 {
    616                   printf("KEY_ADJUST1");
    617                 // enhance_mode = 0;
    618                  robot_suction_vols_set(VACUUM_ENHANCE_VOLTAGE);       
    619                 }
    620                 break;
    621          
    622                
    623              default:
    624              	//printf("default=%x \r\n", s->cmd);
    625                break;         
    626            }    
    627          }
    628          
    629          /****************************************************************
    630          *Function   :  handle_act_wall_following
    631          *Description:  系统状态为ROBOT_STATE_WALLFOLLOW的按键响应函数  
    632          *Input      :  按键消息
    633          *Output     :  无
    634          *Return     :  无
    635          *Others     :  
    636          ******************************************************************/
    637          void handle_act_wall_following(U32 key_val)
    638          {  
    639            //printf("handle_act_wall_following\r\n"); 
    640            switch(key_val)
    641            { 
    642              case KEY_CLEAN | KEY_SHORT_UP:
    643                      //clear_map_index();
    644          
    645              	//act_command_q(CMD_WALL_FOLLOW, CMD_STOP, NULL, 0);
    646              	//sleep(10);
    647                act_command_q(CMD_CLEAN, CMD_RUN, NULL, 0);
    648                songplayer_play_id(SONG_ID_NORMAL_CLEANING_START, 0);
    649                break;
    650                
    651              case KEY_DOCK | KEY_SHORT_UP:
    652                act_command_q(CMD_DOCK, CMD_RUN, NULL, 0);
    653                songplayer_play_id(SONG_ID_DOCKING_START, 0);
    654                break;
    655              
    656              case KEY_SPOT | KEY_SHORT_UP:
    657              	//act_command_q(CMD_WALL_FOLLOW, CMD_STOP, NULL, 0);
    658              	//sleep(10);
    659          	  state_save_and_recover_grid(0);
    660                act_command_q(CMD_SPOT, CMD_RUN, NULL, 0);
    661                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    662                spot_mode = SPOT_MODE_SPIRAL;
    663                break;
    664              
    665              case KEY_GRID | KEY_SHORT_UP:
    666              	//act_command_q(CMD_WALL_FOLLOW, CMD_STOP, NULL, 0);
    667              	//sleep(10);
    668          	  state_save_and_recover_grid(0);
    669                act_command_q(CMD_GRID1, CMD_RUN, NULL, 0);
    670                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    671                spot_mode = SPOT_MODE_GRID;
    672                break;
    673                    
    674              case KEY_WALLFLOW | KEY_SHORT_UP:                  
    675                act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);
    676                songplayer_play_id(SONG_ID_ENTER_PAUSED, 0);
    677                break;
    678              case KEY_POWER | KEY_SHORT_UP:
    679                act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    680                songplayer_play_id(SONG_ID_NORMAL_CLEANING_STOP, 0);
    681                break;                                          
    682               case KEY_ADJUST | KEY_SHORT_UP:
    683                 printf("KEY_ADJUST");
    684                  // enhance_mode = 1;
    685                  robot_suction_vols_set(VACUUM_NORMAL_VOLTAGE);
    686          
    687                break;     
    688               case KEY_ADJUST1 | KEY_SHORT_UP:
    689                 {
    690                   printf("KEY_ADJUST1");
    691                 // enhance_mode = 0;
    692                  robot_suction_vols_set(VACUUM_ENHANCE_VOLTAGE);       
    693                 }
    694                 break;
    695                
    696                  
    697              default:
    698              	//printf("default=%x \r\n", s->cmd);
    699                break;         
    700            }       
    701          }
    702          
    703          /****************************************************************
    704          *Function   :  handle_act_remote_driving
    705          *Description:  系统状态为ROBOT_STATE_REMOTE_DRIVE的按键响应函数  
    706          *Input      :  按键消息
    707          *Output     :  无
    708          *Return     :  无
    709          *Others     :  
    710          ******************************************************************/
    711          void handle_act_remote_driving(U32 key_val)
    712          {  
    713            //printf("handle_act_remote_driving\r\n"); 
    714                
    715          }
    716          
    717          /****************************************************************
    718          *Function   :  handle_act_docking
    719          *Description:  系统状态为ROBOT_STATE_DOCK的按键响应函数  
    720          *Input      :  按键消息
    721          *Output     :  无
    722          *Return     :  无
    723          *Others     :  
    724          ******************************************************************/
    725          void handle_act_docking(U32 key_val)
    726          {  
    727           // printf("handle_act_remote_driving\r\n"); 
    728            switch(key_val)
    729            { 
    730              case KEY_CLEAN | KEY_SHORT_UP:
    731          //    	act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    732          //    	sleep(10);
    733                act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    734                songplayer_play_id(SONG_ID_DOCKING_STOP, 0);
    735                break;          
    736              
    737              case KEY_SPOT | KEY_SHORT_UP:
    738          //    	act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    739          //    	sleep(10);
    740          	  state_save_and_recover_grid(0);
    741                act_command_q(CMD_SPOT, CMD_RUN, NULL, 0);
    742                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    743                spot_mode = SPOT_MODE_SPIRAL;
    744                break;
    745              
    746              case KEY_GRID | KEY_SHORT_UP:
    747          //    	act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    748          //    	sleep(10);
    749                act_command_q(CMD_GRID1, CMD_RUN, NULL, 0);
    750                songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
    751                spot_mode = SPOT_MODE_GRID;
    752                break;
    753                    
    754              case KEY_WALLFLOW | KEY_SHORT_UP:
    755          //    	act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    756          //    	sleep(10);  23456789
    757                act_command_q(CMD_WALL_FOLLOW, CMD_RUN, NULL, 0);
    758                songplayer_play_id(SONG_ID_WALLFOLLOW_CLEANING_START, 0);
    759                break;        
    760              
    761              case KEY_DOCK | KEY_SHORT_UP:
    762              case KEY_POWER | KEY_SHORT_UP:
    763                //act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    764          	  act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);
    765                songplayer_play_id(SONG_ID_DOCKING_STOP, 0);
    766                break;                                          
    767                  
    768              default:
    769              	//printf("default=%x \r\n", s->cmd);
    770                break;         
    771            }     
    772          }
    773          
    774          /****************************************************************
    775          *Function   :  handle_act_charging
    776          *Description:  系统状态为ROBOT_STATE_CHARGING的按键响应函数  
    777          *Input      :  按键消息
    778          *Output     :  无
    779          *Return     :  无
    780          *Others     :  
    781          ******************************************************************/
    782          void handle_act_charging(U32 key_val)
    783          {   
    784          	//printf("handle_act_charging\r\n");
    785              if(battery_switch_check() == 0)
    786            {
    787              printf("battery_switch=%d\r\n",battery_switch_check());
    788                return;
    789            }
    790          
    791            
    792            switch(key_val)
    793            { 
    794              case KEY_CLEAN | KEY_SHORT_UP:
    795                printf("666\r\n");
    796                act_command_q(CMD_CLEAN, CMD_RUN, NULL, 0);
    797                songplayer_play_id(SONG_ID_NORMAL_CLEANING_START, 0);
    798                break;                                       
    799              case KEY_SPOT | KEY_SHORT_UP:
    800          	 case KEY_DOCK | KEY_SHORT_UP:
    801          	 case KEY_POWER | KEY_SHORT_UP:
    802          	 case KEY_LEFT | KEY_SHORT_UP:
    803          	 case KEY_RIGHT | KEY_SHORT_UP:
    804          	 case KEY_FORWARD | KEY_SHORT_UP:
    805                   case KEY_BACKWARD|KEY_SHORT_UP:
    806          	 case KEY_DIRT | KEY_SHORT_UP:
    807          	 case KEY_STOP | KEY_SHORT_UP:
    808          	 case KEY_WIFI | KEY_SHORT_UP:
    809          	 case KEY_ADJUST | KEY_SHORT_UP:
    810          	 case KEY_WALLFLOW | KEY_SHORT_UP: 
    811          	 case KEY_GRID | KEY_SHORT_UP:
    812          	 case KEY_SOS | KEY_SHORT_UP: 	        
    813                   songplayer_play_id(SONG_ID_BUTTON_REJECT, 0);
    814          
    815                  break;   
    816          	default:
    817          		break;
    818            }    
    819          }
    820          /****************************************************************
    821          *Function   :  handle_act_testing
    822          *Description:  UI状态为UI_TEST的按键响应函数  
    823          *Input      :  按键消息
    824          *Output     :  无
    825          *Return     :  无
    826          *Others     :  
    827          ******************************************************************/
    828          void handle_act_testing(U32 key_val)
    829          {   
    830          	//printf("handle_act_testing\r\n"); 
    831            switch(key_val)
    832            { 
    833              case KEY_CLEAN | KEY_SHORT_UP:
    834                ui_test_index++;
    835                if (ui_test_index >= UI_TEST_ITEM_MAX)
    836                {
    837                  ui_test_index = 0;
    838                }
    839                ui_test_cmd = test_item_table[ui_test_index];
    840                break;                                       
    841                  
    842              default:
    843                break;         
    844            }    
    845          }
    846          
    847          /****************************************************************
    848          *Function   :  handle_act_ui_error
    849          *Description:  UI状态为UI_ERROR的按键响应函数  
    850          *Input      :  按键消息
    851          *Output     :  无
    852          *Return     :  无
    853          *Others     :  
    854          ******************************************************************/
    855          void handle_act_ui_error(U32 key_val)
    856          {   
    857          	//printf("handle_act_ui_error\r\n"); 
    858            switch(key_val)
    859            { 
    860              case KEY_CLEAN | KEY_SHORT_UP:
    861                clear_ui_error_number();                                       
    862                set_ui_state(UI_IDLE);
    863                break;
    864                  
    865              default:
    866                break;         
    867            }    
    868          }
    869          
    870          /****************************************************************
    871          *Function   :  handle_act_fullgo
    872          *Description:  UI状态为UI_FULLGO的按键响应函数  
    873          *Input      :  按键消息
    874          *Output     :  无
    875          *Return     :  无
    876          *Others     :  
    877          ******************************************************************/
    878          void handle_act_fullgo(U32 key_val)
    879          {   
    880          	//printf("handle_act_ui_fullgo\r\n");  
    881          	if ((key_val == (KEY_CLEAN | KEY_SHORT_UP)) && board_key)
    882          	{
    883          	  act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
    884              songplayer_play_id(SONG_ID_NORMAL_CLEANING_STOP, 0);
    885              set_ui_state(UI_IDLE);
    886              return;
    887          	}
    888          	
    889            if (key_val & KEY_SHORT_UP)
    890            {
    891              songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);   
    892            }
    893          }
    894          
    895          /****************************************************************
    896          *Function   :  handle_act_common
    897          *Description:  公共的按键响应函数，如果在各种状态下响应都一致的行为，可以放在这里来实现  
    898          *Input      :  按键消息
    899          *Output     :  无
    900          *Return     :  无
    901          *Others     :  
    902          ******************************************************************/
    903          void handle_act_common(U32 key_val)
    904          {
    905          
    906          	switch(key_val)
    907          	{
    908          	  case KEY_LEFT | KEY_DOWN:
    909              	send_left_cmd(CMD_RUN);
    910                break;
    911              
    912              case KEY_RIGHT | KEY_DOWN:
    913                send_right_cmd(CMD_RUN);    
    914                break;
    915              
    916              case KEY_FORWARD | KEY_DOWN:
    917              	send_forward_cmd(CMD_RUN);
    918                break;
    919                
    920              case KEY_BACKWARD | KEY_DOWN:
    921              	send_backward_cmd(CMD_RUN);
    922                break;
    923              
    924              case KEY_LEFT | KEY_SHORT_UP:
    925              case KEY_LEFT | KEY_LONG_UP:
    926              case KEY_LEFT | KEY_HOLD_UP:
    927                send_left_cmd(CMD_STOP);
    928                break;
    929              
    930              case KEY_RIGHT | KEY_SHORT_UP:
    931              case KEY_RIGHT | KEY_LONG_UP:
    932              case KEY_RIGHT | KEY_HOLD_UP:
    933                send_right_cmd(CMD_STOP);
    934                break;
    935              
    936              case KEY_FORWARD | KEY_SHORT_UP:
    937              case KEY_FORWARD | KEY_LONG_UP:
    938              case KEY_FORWARD | KEY_HOLD_UP:
    939                send_forward_cmd(CMD_STOP);
    940                break;
    941                
    942              case KEY_BACKWARD | KEY_SHORT_UP:
    943              case KEY_BACKWARD | KEY_LONG_UP:
    944              case KEY_BACKWARD | KEY_HOLD_UP:
    945                send_backward_cmd(CMD_STOP);
    946                break;        
    947          #if 0   
    948              case KEY_ADJUST | KEY_SHORT_UP:
    949                {
    950                    if (enhance_mode)
    951                    {
    952                        enhance_mode = 0;
    953                     
    954                        printf("normal ####\r\n");
    955                        robot_suction_adjust_set(VACUUM_NORMAL_VOLTAGE);
    956                        if(IS_CLEANNING_MODE(sys_state_info_p.robot_state)
    957                          &&(sys_state_info_p.robot_state != ROBOT_STATE_DOCK))
    958                        {
    959                            robot_suction_vols_set(VACUUM_NORMAL_VOLTAGE);
    960                        }
    961                        songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
    962                    }
    963                    else
    964                    {
    965                       enhance_mode = 1;
    966                 
    967                       printf("fast #####\r\n");
    968                       robot_suction_adjust_set(VACUUM_ENHANCE_VOLTAGE);
    969                       if(IS_CLEANNING_MODE(sys_state_info_p.robot_state)
    970                          &&(sys_state_info_p.robot_state != ROBOT_STATE_DOCK))
    971                        {
    972                            robot_suction_vols_set(VACUUM_ENHANCE_VOLTAGE);
    973                        }
    974                         songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
    975                      // robot_suction_vols_set(VACUUM_ENHANCE_VOLTAGE);
    976                    }
    977                }
    978          
    979                break;
    980          #endif
    981              case KEY_SOS | KEY_SHORT_UP:
    982                //send_backward_cmd(CMD_STOP);
    983                if (get_songplayer_onoff() == 1)
    984                {
    985                  set_songplayer_onoff(0);
    986                }
    987                else
    988                {
    989                  set_songplayer_onoff(1);
    990                  songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
    991                }  
    992                break;
    993              case KEY_CLOCK | KEY_SHORT_UP:
    994                //设置时间前先赋值    
    995                tmp_day.week    = 1;//星期取值范围0-6,0代表星期天，6代表星期六
    996                tmp_day.hour    = 12;
    997                tmp_day.min     = 12;
    998                act_command_q((U32)CMD_CLOCK, (U8)CMD_RUN, (void *)&tmp_day, sizeof(tm));
    999               // set_current_time_info(&set_time);
   1000                break;
   1001              case KEY_SCHEDULE | KEY_SHORT_UP:
   1002                 //设置预约示例 
   1003                 tmp_schedule_info.SCH_ENABLE.BYTE = 0x1;//设置为星期天预约有效
   1004                 tmp_schedule_info.t[0].hour = 8;
   1005                 tmp_schedule_info.t[0].min  = 8;
   1006                 act_command_q(CMD_SCHDULE, CMD_RUN, (void *)&tmp_schedule_info, sizeof(schedule_time_info));
   1007                 //sleep(10);
   1008                 //sys_shutdown(); //关闭DC-DC
   1009                break;
   1010          	case KEY_WIFI | KEY_LONG:
   1011          #if 0         
   1012                 #ifdef USE_UART_WIFI 
   1013                 if(wifi_press_long_flag == 0)
   1014                 {
   1015                     printf("USE_UART_WIFI!!\r\n");
   1016                     #ifdef USE_WIFI_DEMO_1
   1017                     InsertExtCmd(RestoreFactorySet); //进入wifi配网模式
   1018                     set_reset_wifi_flag(1);
   1019                     #elif defined(USE_WIFI_DEMO_2)
   1020                      send_config_network_cmd(); //进入wifi配网模式
   1021                     #endif
   1022                     gpio_set_value(AM_I0_WIFI_LED, 1);
   1023                     songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
   1024                     wifi_press_long_flag = 1;
   1025                     wifi_flag = 1;
   1026                 }
   1027                 #endif
   1028          #endif      
   1029                 break; 
   1030              case KEY_WIFI | KEY_LONG_UP:
   1031              case KEY_WIFI | KEY_HOLD_UP:
   1032          #if 0
   1033                 wifi_press_long_flag = 0;
   1034          #endif
   1035                 break;
   1036              default:
   1037              	break;
   1038            }
   1039          }
   1040          
   1041          /****************************************************************
   1042          *Function   :  handle_act
   1043          *Description:  按键消息的处理函数  
   1044          *Input      :  按键消息
   1045          *Output     :  无
   1046          *Return     :  无
   1047          *Others     :  
   1048          ******************************************************************/
   1049          void handle_act(U32 key_val)
   1050          {	
   1051          	UI_STATE_E s;
   1052          	
   1053          	s = get_ui_state();
   1054              
   1055               view_key(key_val);
   1056          /*
   1057          	if (1) 
   1058          	{
   1059          	  set_ui_state(UI_FULLGO);
   1060          	  allow_self_test = 0;
   1061          	  fullgo_cnt = FULLGO_START_TIME;
   1062          	  printf("enter fullgo\r\n"); 
   1063          	}
   1064          */        
   1065                // printf("handle_act  key_val=%x\r\n",key_val);
   1066                 // if((key_val == (KEY_CLEAN | KEY_SHORT_UP)) && allow_self_test && ir_key) 
   1067                 // {
   1068                 //  printf("key_clean\r\n");
   1069                //  } 
   1070          	if (((key_val == (KEY_CLEAN | KEY_HOLD)) && allow_self_test && board_key) ||((key_val == (KEY_CLEAN | KEY_LONG_UP)) && allow_self_test && ir_key))
   1071          	{
   1072                 #ifdef USE_UART_WIFI 
   1073                 if(wifi_press_long_flag == 0)
   1074                 {
   1075                     wifi_led=1;
   1076                     printf("USE_UART_WIFI!!\r\n");
   1077                     #ifdef USE_WIFI_DEMO_1
   1078                     InsertExtCmd(RestoreFactorySet); //进入wifi配网模式
   1079                     set_reset_wifi_flag(1);
   1080                     #elif defined(USE_WIFI_DEMO_2)
   1081                      send_config_network_cmd(); //进入wifi配网模式
   1082                     #endif
   1083                     //gpio_set_value(AM_I0_WIFI_LED, 1);
   1084                     songplayer_play_id(SONG_ID_BUTTON_CLICK, 0);
   1085                     wifi_press_long_flag = 1;
   1086                     wifi_flag = 1;
   1087                 }
   1088                 #endif          
   1089                    
   1090          #if 0
   1091          	  set_ui_state(UI_TEST);
   1092          	  allow_self_test = 0;
   1093          	  ui_test_cmd = test_item_table[ui_test_index];
   1094          	  printf("enter self test\r\n"); 
   1095          #endif
   1096          	}
   1097          	if ((key_val == (KEY_CLEAN | KEY_HOLD)) && allow_self_test && ir_key) 
   1098          	{                  
   1099          #if 0        
   1100          	  set_ui_state(UI_FULLGO);
   1101          	  allow_self_test = 0;
   1102          	  fullgo_cnt = FULLGO_START_TIME;
   1103          	  printf("enter fullgo\r\n"); 
   1104          #endif        
   1105          	}
   1106          	
   1107          	if (s == UI_TEST)
   1108          	{	
   1109          	  handle_act_testing(key_val);
   1110          	  return;
   1111          	}	
   1112          	else if (s == UI_ERROR)
   1113          	{
   1114          	  handle_act_ui_error(key_val);
   1115          	  return;
   1116          	}
   1117          	else if (s == UI_FULLGO)
   1118          	{
   1119          	  handle_act_fullgo(key_val);
   1120          	  return;
   1121          	}
   1122          		
   1123            //printf("robot_state=%d\r\n",sys_state_info_p.robot_state);			
   1124            switch (sys_state_info_p.robot_state)
   1125            {
   1126              case ROBOT_STATE_WAITING:
   1127                handle_act_waiting(key_val);
   1128              	break;
   1129              
   1130              case ROBOT_STATE_CLEANING_ROOM:
   1131                handle_act_running(key_val);
   1132              	break;
   1133              
   1134              case ROBOT_STATE_PAUSE:
   1135                handle_act_pausing(key_val);
   1136              	break;
   1137              	
   1138              case ROBOT_STATE_WALLFOLLOW:
   1139                handle_act_wall_following(key_val);
   1140              	break;
   1141              
   1142              case ROBOT_STATE_SPOTTING:
   1143                handle_act_spotting(key_val);
   1144              	break;
   1145              		
   1146              case ROBOT_STATE_REMOTE_DRIVE:
   1147                handle_act_remote_driving(key_val);
   1148              	break;
   1149              
   1150              case ROBOT_STATE_DOCK:
   1151                handle_act_docking(key_val);
   1152              	break;
   1153              		
   1154              case ROBOT_STATE_CHARGING:
   1155                
   1156                handle_act_charging(key_val);
   1157                key_val=KEY_NULL;
   1158              	break;    	    
   1159              		
   1160              default:
   1161              	break;
   1162            }
   1163            
   1164            handle_act_common(key_val);
   1165          }
   1166          
   1167          u8 last_state = 0;
   1168          extern void print_touch(void);
   1169          extern void print_cliff(void);
   1170          /****************************************************************
   1171          *Function   :  ui_handle_idle
   1172          *Description:  idle函数  
   1173          *Input      :  无
   1174          *Output     :  无
   1175          *Return     :  无
   1176          *Others     :  
   1177          ******************************************************************/
   1178          void ui_handle_idle(void)
   1179          {
   1180            sys_info_get(SYS_STATE_INFO, (long )&sys_state_info_p);
   1181            if (last_state != sys_state_info_p.robot_state)
   1182          	{
   1183          	    printf("new_state:%d \r\n", sys_state_info_p.robot_state);
   1184                 if((sys_state_info_p.robot_state != ROBOT_STATE_PAUSE) &&(clean_pause_flag == 1))
   1185                 {       
   1186                     clean_pause_flag =0;//状态改变，对该标志位清零               
   1187                 }
   1188                 
   1189          	}
   1190          	//print_touch();
   1191                  //print_cliff();
   1192                  //motor_encode_get();
   1193           //       printf("motor_encode_get: left_ticks=%d left_abs_ticks=%d right_ticks=%d right_abs_ticks=%d\r\n",
   1194           //        motor_encode_t.left_ticks,motor_encode_t.left_abs_ticks, motor_encode_t.right_ticks, 
   1195           //        motor_encode_t.right_abs_ticks);  
   1196                  
   1197          /*        printf("left_ticks=%d\r\n", motor_encode_get()->left_ticks);
   1198                  printf("left_abs_ticks=%d\r\n", motor_encode_get()->left_abs_ticks);
   1199                  printf("right_abs_ticks=%d\r\n", motor_encode_get()->right_abs_ticks);
   1200                  printf("right_ticks:=%d\r\n", motor_encode_get()->right_ticks);
   1201           */       
   1202          	last_state = sys_state_info_p.robot_state;
   1203          #if 0//luyanjin 
   1204            //没装入垃圾盒？
   1205            if(gpio_get_value(AM_IO_BUSTBIN_DETECT))
   1206            {
   1207              printf("bustbin=%d\r\n",gpio_get_value(AM_IO_BUSTBIN_DETECT));
   1208              vac_current_count++;
   1209              if (vac_current_count >= 5) {
   1210                set_ui_error_number(UI_ERROR_10_DUSTBIN_UN_INSERT);
   1211              }
   1212            }else {
   1213              vac_current_count = 0;
   1214            }
   1215          #endif
   1216          } 
   1217          /****************************************************************
   1218          *Function   :  direction_key_recover_handle
   1219          *Description:  对松开方向键的处理 
   1220          *Input      :  无
   1221          *Output     :  无
   1222          *Return     :  无
   1223          *Others     :  by ljh
   1224          ******************************************************************/
   1225          void direction_key_recover_handle(void)
   1226          {
   1227          	static u32 one_second =0;
   1228          	if(direction_key_up_flag)
   1229          	{
   1230          	  	if(get_total_seconds()>(one_second+1))//松开方向键1s之后使状态跳回原来的清扫状态
   1231          		{
   1232                      if(state_save_and_recover(2) == ROBOT_STATE_DOCK)
   1233                      {
   1234                          state_save_and_recover(1);
   1235                      }
   1236          			if((state_save_and_recover(2) == ROBOT_STATE_PAUSE) &&\
   1237                            (direction_key_pause != 1))
   1238          			{
   1239                          state_save_and_recover(1);  					
   1240          			}
   1241          			else
   1242                      {
   1243                          act_command_q(CMD_PAUSE, CMD_RUN, NULL, 0);
   1244                          direction_key_pause = 0;
   1245                      }							
   1246          			direction_key_up_flag =0;
   1247          		}
   1248          		return;
   1249          	}
   1250          	one_second = get_total_seconds();
   1251          }
   1252          
   1253          /****************************************************************
   1254          *Function   :  cleaning_complete_handle
   1255          *Description:  对清扫完成的处理 
   1256          *Input      :  无
   1257          *Output     :  无
   1258          *Return     :  无
   1259          *Others     :  by ljh
   1260          ******************************************************************/
   1261          void cleaning_complete_handle(void)
   1262          {	
   1263          	if(sys_state_info_p.robot_state == ROBOT_STATE_SPOTTING)
   1264          	{
   1265          		sleep(10);
   1266          		state_save_and_recover_grid(1);
   1267          		return;
   1268          	}
   1269          	else
   1270          	{
   1271          		songplayer_play_id(SONG_ID_NORMAL_CLEANING_COMPLETE, 1);
   1272          	}
   1273          	
   1274          }
   1275          
   1276          /****************************************************************
   1277          *Function   :  state_save_and_recover_grid
   1278          *Description:  状态保存与状态恢复(用于局部清扫) 
   1279          *Input      :  0:保存当前状态   1：恢复保存的状态  2:只返回保存的状态
   1280          *Output     :  无
   1281          *Return     :  无
   1282          *Others     :  by ljh
   1283          ******************************************************************/
   1284          void state_save_and_recover_grid(u8 flag)
   1285          {
   1286          	static u8 state;
   1287          	if(flag ==0)
   1288          	{
   1289          		state = sys_state_info_p.robot_state;
   1290          		printf("save_state_grid=%d\r\n",state);
   1291          	}
   1292          	if(flag ==1)
   1293          	{
   1294          	  printf("recover_state_grid=%d\r\n",state);
   1295          	  switch(state)
   1296          	  { 
   1297          		case ROBOT_STATE_CLEANING_ROOM:
   1298          		  act_command_q(CMD_CLEAN, CMD_RUN, NULL, 0);
   1299          		  songplayer_play_id(SONG_ID_NORMAL_CLEANING_START, 0);
   1300          		  break;
   1301          
   1302          		case ROBOT_STATE_WALLFOLLOW:
   1303          		  act_command_q(CMD_WALL_FOLLOW, CMD_RUN, NULL, 0);
   1304          		  songplayer_play_id(SONG_ID_WALLFOLLOW_CLEANING_START, 0);
   1305          		  break;  
   1306          		  
   1307          		case ROBOT_STATE_PAUSE:
   1308          		  act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);  
   1309          		  break;	 
   1310          		  
   1311          		case ROBOT_STATE_DOCK:
   1312          		  act_command_q(CMD_DOCK, CMD_RUN, NULL, 0);
   1313          		  songplayer_play_id(SONG_ID_DOCKING_START, 0);
   1314          		  break;
   1315          		  
   1316          		case ROBOT_STATE_WAITING:   
   1317          		  //act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
   1318          		  //break; 
   1319          		  
   1320          		case ROBOT_STATE_SPOTTING:
   1321          //		  act_command_q(CMD_SPOT, CMD_RUN, NULL, 0);
   1322          //		  songplayer_play_id(SONG_ID_SPOT_CLEANING_START, 0);
   1323          //		  spot_mode = SPOT_MODE_SPIRAL;
   1324          //		  break;		                                      
   1325          		  
   1326          		default:
   1327          		  act_command_q(CMD_CLEAN, CMD_STOP, NULL, 0);
   1328          		  sleep(10);
   1329          		  songplayer_play_id(SONG_ID_NORMAL_CLEANING_COMPLETE, 1);//清扫完成语音
   1330          			//printf("default=%x \r\n", s->cmd);
   1331          		  break;         
   1332          	  }    			
   1333          	
   1334          	}
   1335          }
   1336          
   1337          /****************************************************************
   1338          *Function   :  state_save_and_recover
   1339          *Description:  状态保存与状态恢复(按下方向键前的处理，用于暂停状态与dock状态) 
   1340          *Input      :  0:保存当前状态   1：恢复保存的状态  2:只返回保存的状态
   1341          *Output     :  无
   1342          *Return     :  无
   1343          *Others     :  by ljh
   1344          ******************************************************************/
   1345          u8 state_save_and_recover(u8 flag)
   1346          {
   1347          	static u8 state;
   1348          	if(flag ==0)
   1349          	{
   1350          		state = sys_state_info_p.robot_state;
   1351          		printf("save_state=%d\r\n",state);
   1352          	}
   1353          	if(flag ==1)
   1354          	{
   1355          	  printf("recover_state=%d\r\n",state);
   1356          	  switch(state)
   1357          	  { 		  
   1358          		case ROBOT_STATE_PAUSE:
   1359          		  act_command_q(CMD_PAUSE, CMD_STOP, NULL, 0);  
   1360          		  robot_suction_ctrl(1);	//关风机
   1361          		  robot_sidebrush_vols_set(0);//关边刷
   1362          		  robot_midbrush_vols_set(0);//关主刷
   1363          		  printf("robot stop\r\n");
   1364          		  break;	 
   1365          		  
   1366          		case ROBOT_STATE_DOCK:
   1367          		  act_command_q(CMD_DOCK, CMD_RUN, NULL, 0);
   1368          		  songplayer_play_id(SONG_ID_DOCKING_START, 0);
   1369          		  break;		       
   1370          	  } 
   1371          	  state =0;
   1372          	}
   1373              return state;
   1374          	
   1375          }
   1376          
   1377          
   1378          
   1379          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _act_exit
       8   _act_init
         0   -> clear_map_index
         8   -> get_ir_state
         8   -> get_key_state
         8   -> get_wifi_uart_cmd_state
      16   act_routine
         0   -> direction_key_recover_handle
        16   -> ext_act_handle
        16   -> handle_act
       8   cleaning_complete_handle
         8   -> sleep
         0   -> songplayer_play_id
         0   -> state_save_and_recover_grid
       8   direction_key_recover_handle
         8   -> act_command_q
         8   -> get_total_seconds
         8   -> state_save_and_recover
      16   ext_act_handle
        16   -- Indirect call
        16   -> act_command_q
        16   -> exception_handle
        16   -> robot_sensor_gather_start
        16   -> sleep_handle
        16   -> songplayer_play_id
       0   get_enter_sleep_state
       0   get_start_docking_state
       0   get_ui_state
      16   handle_act
        16   -- Indirect call
        16   -> InsertExtCmd
        16   -> handle_act_charging
         0   -> handle_act_common
        16   -> handle_act_docking
         0   -> handle_act_fullgo
        16   -> handle_act_pausing
        16   -> handle_act_running
        16   -> handle_act_spotting
         0   -> handle_act_testing
         0   -> handle_act_ui_error
        16   -> handle_act_waiting
        16   -> handle_act_wall_following
        16   -> set_reset_wifi_flag
        16   -> songplayer_play_id
        16   -> view_key
      16   handle_act_charging
         0   -- Indirect call
        16   -- Indirect call
        16   -> act_command_q
        16   -> battery_switch_check
         0   -> songplayer_play_id
       8   handle_act_common
         0   -> act_command_q
         8   -> get_songplayer_onoff
         0   -> send_backward_cmd
         0   -> send_forward_cmd
         0   -> send_left_cmd
         0   -> send_right_cmd
         0   -> set_songplayer_onoff
         8   -> set_songplayer_onoff
         0   -> songplayer_play_id
       8   handle_act_docking
         8   -> act_command_q
         0   -> songplayer_play_id
         8   -> songplayer_play_id
         8   -> state_save_and_recover_grid
       8   handle_act_fullgo
         8   -> act_command_q
         0   -> songplayer_play_id
         8   -> songplayer_play_id
       8   handle_act_pausing
         8   -> act_command_q
         8   -> sleep
         0   -> songplayer_play_id
         8   -> songplayer_play_id
         8   -> state_save_and_recover_grid
       0   handle_act_remote_driving
       8   handle_act_running
         8   -> act_command_q
         0   -> robot_suction_vols_set
         8   -> sleep
         0   -> songplayer_play_id
         8   -> songplayer_play_id
         8   -> state_save_and_recover_grid
       8   handle_act_spotting
         8   -- Indirect call
         8   -> act_command_q
         0   -> robot_suction_vols_set
         8   -> songplayer_play_id
       0   handle_act_testing
       8   handle_act_ui_error
         8   -> clear_ui_error_number
       8   handle_act_waiting
         8   -> act_command_q
         8   -> clear_map_index
         8   -> sleep
         0   -> songplayer_play_id
         8   -> songplayer_play_id
         8   -> state_save_and_recover_grid
       8   handle_act_wall_following
         8   -- Indirect call
         8   -> act_command_q
         0   -> robot_suction_vols_set
         0   -> songplayer_play_id
         8   -> songplayer_play_id
         8   -> state_save_and_recover_grid
       0   set_enter_sleep_state
       0   set_start_docking_state
       0   set_ui_state
       8   sleep_handle
         8   -> act_command_q
         8   -> robot_universl_wheel_exit
         8   -> robot_universl_wheel_init
      16   state_save_and_recover
        16   -- Indirect call
        16   -> act_command_q
        16   -> robot_midbrush_vols_set
        16   -> robot_sidebrush_vols_set
        16   -> robot_suction_ctrl
        16   -> songplayer_play_id
      16   state_save_and_recover_grid
        16   -- Indirect call
         0   -> act_command_q
        16   -> act_command_q
        16   -> sleep
         0   -> songplayer_play_id
       8   ui_handle_idle
         8   -- Indirect call
         8   -> sys_info_get


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable46_10
       4  ??DataTable46_11
       4  ??DataTable46_12
       4  ??DataTable46_13
       4  ??DataTable46_14
       4  ??DataTable46_15
       4  ??DataTable46_16
       4  ??DataTable46_17
       4  ??DataTable46_18
       4  ??DataTable46_19
       4  ??DataTable46_2
       4  ??DataTable46_20
       4  ??DataTable46_21
       4  ??DataTable46_22
       4  ??DataTable46_23
       4  ??DataTable46_24
       4  ??DataTable46_25
       4  ??DataTable46_26
       4  ??DataTable46_3
       4  ??DataTable46_4
       4  ??DataTable46_5
       4  ??DataTable46_6
       4  ??DataTable46_7
       4  ??DataTable46_8
       4  ??DataTable46_9
       8  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine10
      14  ?Subroutine11
      10  ?Subroutine12
      14  ?Subroutine13
      14  ?Subroutine14
       8  ?Subroutine15
       6  ?Subroutine16
      16  ?Subroutine17
      14  ?Subroutine18
      14  ?Subroutine19
       8  ?Subroutine2
      10  ?Subroutine3
       4  ?Subroutine4
      14  ?Subroutine5
      14  ?Subroutine6
      14  ?Subroutine7
      14  ?Subroutine8
      14  ?Subroutine9
      12  ?_0
      12  ?_1
      16  ?_10
      20  ?_2
       8  ?_3
      20  ?_4
      16  ?_5
      24  ?_6
      24  ?_7
      16  ?_8
      20  ?_9
       2  _act_exit
      32  _act_init
     132  act_routine
       1  clean_index
      34  cleaning_complete_handle
      90  direction_key_recover_handle
       8  direction_key_up_flag
          direction_key_pause
          one_second
       1  enter_sleep_state
     198  ext_act_handle
       8  get_enter_sleep_state
       8  get_start_docking_state
       8  get_ui_state
     222  handle_act
     184  handle_act_charging
     242  handle_act_common
     116  handle_act_docking
      46  handle_act_fullgo
     160  handle_act_pausing
       2  handle_act_remote_driving
     156  handle_act_running
     182  handle_act_spotting
      36  handle_act_testing
      24  handle_act_ui_error
     128  handle_act_waiting
     156  handle_act_wall_following
       8  set_enter_sleep_state
       8  set_start_docking_state
       8  set_ui_state
      96  sleep_handle
     106  state_save_and_recover
     130  state_save_and_recover_grid
      48  sys_state_info_p
          ui_state
          start_docking_flag
          allow_self_test
          spot_mode
          board_key
          ir_key
          clean_pause_flag
          special_sleep_flag
          wifi_flag
          wifi_press_long_flag
          wifi_led
          last_state
          state
          state
          goto_sleep_cnt
          waiting_state_cnt
          fullgo_cnt
          key_state_p
          key_ir_p
          wifi_uart_cmd_state_p
      68  tmp_day
          tmp_schedule_info
      54  ui_handle_idle
       8  ui_test_index
          ui_test_cmd

 
    86 bytes in section .bss
    48 bytes in section .data
 3 100 bytes in section .text
 
 3 100 bytes of CODE memory
   134 bytes of DATA memory

Errors: none
Warnings: 3
